<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match-3 Game - Kaplay</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 4px solid white;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <script src="kaplay.js"></script>
    <script>
        // Web Audio API - Sound Effects Module
        const SoundFX = {
            audioContext: null,

            init() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            },

            // Resume audio context (required for some browsers)
            resume() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            },

            // Gem selection sound - soft click
            select() {
                this.resume();
                const ctx = this.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.05);

                gain.gain.setValueAtTime(0.15, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);

                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.05);
            },

            // Gem swap sound
            swap() {
                this.resume();
                const ctx = this.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, ctx.currentTime + 0.1);

                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            },

            // Match sound - varies by match size
            match(matchSize = 3) {
                this.resume();
                const ctx = this.audioContext;
                const baseFreq = 400 + (matchSize - 3) * 100;

                // Create multiple oscillators for a richer sound
                for (let i = 0; i < 2; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = i === 0 ? 'sine' : 'triangle';
                    osc.frequency.setValueAtTime(baseFreq + i * 200, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5 + i * 200, ctx.currentTime + 0.15);

                    gain.gain.setValueAtTime(0.15, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);

                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(ctx.currentTime + i * 0.02);
                    osc.stop(ctx.currentTime + 0.15);
                }
            },

            // Invalid swap sound
            invalid() {
                this.resume();
                const ctx = this.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(150, ctx.currentTime + 0.15);

                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);

                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.15);
            },

            // Gem fall sound
            fall() {
                this.resume();
                const ctx = this.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.2);

                gain.gain.setValueAtTime(0.08, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);

                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.2);
            },

            // Game over sound
            gameOver() {
                this.resume();
                const ctx = this.audioContext;

                // Descending tone sequence
                const notes = [400, 350, 300, 250];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, ctx.currentTime);

                    gain.gain.setValueAtTime(0, ctx.currentTime + i * 0.15);
                    gain.gain.linearRampToValueAtTime(0.15, ctx.currentTime + i * 0.15 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.15);

                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(ctx.currentTime + i * 0.15);
                    osc.stop(ctx.currentTime + i * 0.15 + 0.15);
                });
            },

            // New game sound
            newGame() {
                this.resume();
                const ctx = this.audioContext;

                // Ascending tone sequence
                const notes = [300, 400, 500, 600];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, ctx.currentTime);

                    gain.gain.setValueAtTime(0, ctx.currentTime + i * 0.1);
                    gain.gain.linearRampToValueAtTime(0.12, ctx.currentTime + i * 0.1 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.1 + 0.1);

                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(ctx.currentTime + i * 0.1);
                    osc.stop(ctx.currentTime + i * 0.1 + 0.1);
                });
            }
        };

        // Initialize sound effects
        SoundFX.init();

        // Initialize Kaplay
        const k = kaplay({
            width: 600,
            height: 700,
            background: [20, 20, 40]
        });

        // Game constants
        const GRID_SIZE = 8;
        const TILE_SIZE = 60;
        const GRID_OFFSET_X = 60;
        const GRID_OFFSET_Y = 120;
        const GEM_TYPES = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];

        // Game state
        let score = 0;
        let moves = 30;
        let selectedTile = null;
        let grid = [];
        let isProcessing = false;

        // Color mapping
        const GEM_COLORS = {
            'red': rgb(220, 50, 50),
            'blue': rgb(50, 120, 220),
            'green': rgb(50, 200, 80),
            'yellow': rgb(255, 220, 50),
            'purple': rgb(180, 80, 180),
            'orange': rgb(255, 140, 50)
        };

        // Create a gem sprite
        function createGem(x, y, type) {
            return k.add([
                k.rect(TILE_SIZE - 10, TILE_SIZE - 10, { radius: 8 }),
                k.pos(
                    GRID_OFFSET_X + x * TILE_SIZE + 5,
                    GRID_OFFSET_Y + y * TILE_SIZE + 5
                ),
                k.color(GEM_COLORS[type]),
                k.area(),
                k.anchor("topleft"),
                k.outline(3, rgb(255, 255, 255)),
                {
                    gridX: x,
                    gridY: y,
                    gemType: type,
                    isGem: true
                }
            ]);
        }

        // Initialize grid
        function initGrid() {
            grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    let type;
                    do {
                        type = k.choose(GEM_TYPES);
                    } while (wouldCreateMatch(x, y, type));

                    grid[y][x] = createGem(x, y, type);
                }
            }
        }

        // Check if placing a gem would create a match
        function wouldCreateMatch(x, y, type) {
            // Check horizontal
            let countLeft = 0;
            for (let i = x - 1; i >= 0; i--) {
                if (grid[y] && grid[y][i] && grid[y][i].gemType === type) {
                    countLeft++;
                } else {
                    break;
                }
            }

            let countRight = 0;
            for (let i = x + 1; i < GRID_SIZE; i++) {
                if (grid[y] && grid[y][i] && grid[y][i].gemType === type) {
                    countRight++;
                } else {
                    break;
                }
            }

            if (countLeft + countRight >= 2) return true;

            // Check vertical
            let countUp = 0;
            for (let i = y - 1; i >= 0; i--) {
                if (grid[i] && grid[i][x] && grid[i][x].gemType === type) {
                    countUp++;
                } else {
                    break;
                }
            }

            let countDown = 0;
            for (let i = y + 1; i < GRID_SIZE; i++) {
                if (grid[i] && grid[i][x] && grid[i][x].gemType === type) {
                    countDown++;
                } else {
                    break;
                }
            }

            if (countUp + countDown >= 2) return true;

            return false;
        }

        // Find all matches on the board
        function findMatches() {
            let matches = [];

            // Check horizontal matches
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE - 2; x++) {
                    let type = grid[y][x].gemType;
                    let matchCount = 1;

                    for (let i = x + 1; i < GRID_SIZE; i++) {
                        if (grid[y][i].gemType === type) {
                            matchCount++;
                        } else {
                            break;
                        }
                    }

                    if (matchCount >= 3) {
                        for (let i = 0; i < matchCount; i++) {
                            if (!matches.includes(grid[y][x + i])) {
                                matches.push(grid[y][x + i]);
                            }
                        }
                    }
                }
            }

            // Check vertical matches
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE - 2; y++) {
                    let type = grid[y][x].gemType;
                    let matchCount = 1;

                    for (let i = y + 1; i < GRID_SIZE; i++) {
                        if (grid[i][x].gemType === type) {
                            matchCount++;
                        } else {
                            break;
                        }
                    }

                    if (matchCount >= 3) {
                        for (let i = 0; i < matchCount; i++) {
                            if (!matches.includes(grid[y + i][x])) {
                                matches.push(grid[y + i][x]);
                            }
                        }
                    }
                }
            }

            return matches;
        }

        // Remove matched gems
        async function removeMatches(matches) {
            if (matches.length === 0) return false;

            score += matches.length * 10;

            // Play match sound based on match size
            SoundFX.match(matches.length);

            // Animate and destroy
            for (let gem of matches) {
                grid[gem.gridY][gem.gridX] = null;
                k.destroy(gem);
            }

            await k.wait(0.2);
            return true;
        }

        // Apply gravity
        async function applyGravity() {
            let moved = false;

            for (let x = 0; x < GRID_SIZE; x++) {
                let emptySpaces = 0;

                for (let y = GRID_SIZE - 1; y >= 0; y--) {
                    if (!grid[y][x] || grid[y][x].paused) {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        let gem = grid[y][x];
                        let newY = y + emptySpaces;

                        grid[y][x] = null;
                        grid[newY][x] = gem;
                        gem.gridY = newY;

                        k.tween(
                            gem.pos.y,
                            GRID_OFFSET_Y + newY * TILE_SIZE + 5,
                            0.3,
                            (val) => gem.pos.y = val,
                            k.easings.easeOutBounce
                        );

                        moved = true;
                    }
                }
            }

            if (moved) {
                SoundFX.fall();
                await k.wait(0.3);
            }
            return moved;
        }

        // Fill empty spaces
        async function fillEmptySpaces() {
            let filled = false;

            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    if (!grid[y][x] || grid[y][x].paused) {
                        let type = k.choose(GEM_TYPES);
                        let gem = createGem(x, y - GRID_SIZE, type);
                        gem.gridY = y;
                        grid[y][x] = gem;

                        k.tween(
                            gem.pos.y,
                            GRID_OFFSET_Y + y * TILE_SIZE + 5,
                            0.4,
                            (val) => gem.pos.y = val,
                            k.easings.easeOutBounce
                        );

                        filled = true;
                    }
                }
            }

            if (filled) await k.wait(0.4);
            return filled;
        }

        // Process matches
        async function processMatches() {
            isProcessing = true;
            let foundMatches = true;

            while (foundMatches) {
                let matches = findMatches();
                if (matches.length > 0) {
                    await removeMatches(matches);
                    await applyGravity();
                    await fillEmptySpaces();
                } else {
                    foundMatches = false;
                }
            }

            isProcessing = false;
        }

        // Swap two gems
        async function swapGems(gem1, gem2) {
            if (isProcessing) return;
            isProcessing = true;

            // Play swap sound
            SoundFX.swap();

            let tempX = gem1.gridX;
            let tempY = gem1.gridY;

            grid[gem1.gridY][gem1.gridX] = gem2;
            grid[gem2.gridY][gem2.gridX] = gem1;

            gem1.gridX = gem2.gridX;
            gem1.gridY = gem2.gridY;
            gem2.gridX = tempX;
            gem2.gridY = tempY;

            // Animate swap
            let gem1TargetX = GRID_OFFSET_X + gem1.gridX * TILE_SIZE + 5;
            let gem1TargetY = GRID_OFFSET_Y + gem1.gridY * TILE_SIZE + 5;
            let gem2TargetX = GRID_OFFSET_X + gem2.gridX * TILE_SIZE + 5;
            let gem2TargetY = GRID_OFFSET_Y + gem2.gridY * TILE_SIZE + 5;

            k.tween(gem1.pos.x, gem1TargetX, 0.2, (val) => gem1.pos.x = val, k.easings.linear);
            k.tween(gem1.pos.y, gem1TargetY, 0.2, (val) => gem1.pos.y = val, k.easings.linear);
            k.tween(gem2.pos.x, gem2TargetX, 0.2, (val) => gem2.pos.x = val, k.easings.linear);
            k.tween(gem2.pos.y, gem2TargetY, 0.2, (val) => gem2.pos.y = val, k.easings.linear);

            await k.wait(0.2);

            // Check for matches
            let matches = findMatches();

            if (matches.length > 0) {
                moves--;
                await processMatches();
            } else {
                // Invalid swap - play error sound
                SoundFX.invalid();

                // Swap back
                grid[gem1.gridY][gem1.gridX] = gem2;
                grid[gem2.gridY][gem2.gridX] = gem1;

                let temp = gem1.gridX;
                gem1.gridX = gem2.gridX;
                gem2.gridX = temp;

                temp = gem1.gridY;
                gem1.gridY = gem2.gridY;
                gem2.gridY = temp;

                gem1TargetX = GRID_OFFSET_X + gem1.gridX * TILE_SIZE + 5;
                gem1TargetY = GRID_OFFSET_Y + gem1.gridY * TILE_SIZE + 5;
                gem2TargetX = GRID_OFFSET_X + gem2.gridX * TILE_SIZE + 5;
                gem2TargetY = GRID_OFFSET_Y + gem2.gridY * TILE_SIZE + 5;

                k.tween(gem1.pos.x, gem1TargetX, 0.2, (val) => gem1.pos.x = val, k.easings.linear);
                k.tween(gem1.pos.y, gem1TargetY, 0.2, (val) => gem1.pos.y = val, k.easings.linear);
                k.tween(gem2.pos.x, gem2TargetX, 0.2, (val) => gem2.pos.x = val, k.easings.linear);
                k.tween(gem2.pos.y, gem2TargetY, 0.2, (val) => gem2.pos.y = val, k.easings.linear);

                await k.wait(0.2);
            }

            isProcessing = false;
        }

        // Game scene
        k.scene("game", () => {
            // Title
            k.add([
                k.text("MATCH-3", { size: 48, font: "sans-serif" }),
                k.pos(k.width() / 2, 40),
                k.anchor("center"),
                k.color(255, 255, 255)
            ]);

            // Score display
            const scoreText = k.add([
                k.text("Score: 0", { size: 24 }),
                k.pos(20, 80),
                k.color(255, 255, 255)
            ]);

            // Moves display
            const movesText = k.add([
                k.text("Moves: 30", { size: 24 }),
                k.pos(k.width() - 20, 80),
                k.anchor("topright"),
                k.color(255, 255, 255)
            ]);

            k.onUpdate(() => {
                scoreText.text = `Score: ${score}`;
                movesText.text = `Moves: ${moves}`;

                if (moves <= 0 && !isProcessing) {
                    SoundFX.gameOver();
                    k.go("gameover");
                }
            });

            // Initialize grid
            initGrid();

            // Play new game sound
            SoundFX.newGame();

            // Handle clicks
            k.onClick(() => {
                if (isProcessing) return;

                let clicked = k.get("*").filter(obj =>
                    obj.isGem && obj.isHovering()
                );

                if (clicked.length > 0) {
                    let gem = clicked[0];

                    if (!selectedTile) {
                        // Play select sound
                        SoundFX.select();
                        selectedTile = gem;
                        selectedTile.opacity = 0.7;
                    } else {
                        let dx = Math.abs(gem.gridX - selectedTile.gridX);
                        let dy = Math.abs(gem.gridY - selectedTile.gridY);

                        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                            swapGems(selectedTile, gem);
                        } else {
                            // Deselect and select new gem
                            SoundFX.select();
                            selectedTile.opacity = 1;
                            selectedTile = gem;
                            selectedTile.opacity = 0.7;
                            return;
                        }

                        selectedTile.opacity = 1;
                        selectedTile = null;
                    }
                }
            });
        });

        // Game over scene
        k.scene("gameover", () => {
            k.add([
                k.text("GAME OVER", { size: 64, font: "sans-serif" }),
                k.pos(k.width() / 2, k.height() / 2 - 80),
                k.anchor("center"),
                k.color(255, 100, 100)
            ]);

            k.add([
                k.text(`Final Score: ${score}`, { size: 32 }),
                k.pos(k.width() / 2, k.height() / 2),
                k.anchor("center"),
                k.color(255, 255, 255)
            ]);

            k.add([
                k.text("Click to Play Again", { size: 24 }),
                k.pos(k.width() / 2, k.height() / 2 + 80),
                k.anchor("center"),
                k.color(200, 200, 200)
            ]);

            k.onClick(() => {
                SoundFX.newGame();
                score = 0;
                moves = 30;
                selectedTile = null;
                grid = [];
                isProcessing = false;
                k.go("game");
            });
        });

        // Start the game
        k.go("game");
    </script>
</body>
</html>
